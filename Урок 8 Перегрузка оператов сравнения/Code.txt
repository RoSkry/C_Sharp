class Program
    {
        public class LooseLeafCalendar // перекидной календарь
        {
            int _year;
            int _month;
            int _day;

            public LooseLeafCalendar()
            {
                _year = DateTime.Today.Year;
                _month = DateTime.Today.Month;
                _day = DateTime.Today.Day;
            }

            public static LooseLeafCalendar operator ++(LooseLeafCalendar calendar)
            {
                DateTime temp = new DateTime(calendar._year, calendar._month, calendar._day);
                DateTime result = temp.AddMonths(1);
                calendar._year = result.Year;
                calendar._month = result.Month;
                calendar._day = result.Day;

                return calendar;
            }
            public static LooseLeafCalendar operator --(LooseLeafCalendar calendar)
            {
                DateTime temp = new DateTime(calendar._year, calendar._month, calendar._day);
                DateTime result = temp.AddMonths(-1);
                calendar._year = result.Year;
                calendar._month = result.Month;
                calendar._day = result.Day;

                return calendar;
            }
            public static LooseLeafCalendar operator +(LooseLeafCalendar calendar, int n)
            {
                DateTime temp = new DateTime(calendar._year, calendar._month, calendar._day);
                DateTime result = temp.AddMonths(n);
                calendar._year = result.Year;
                calendar._month = result.Month;
                calendar._day = result.Day;

                return calendar;
            }
            public static LooseLeafCalendar operator -(LooseLeafCalendar calendar, int n)
            {
                DateTime temp = new DateTime(calendar._year, calendar._month, calendar._day);
                DateTime result = temp.AddMonths(-n);
                calendar._year = result.Year;
                calendar._month = result.Month;
                calendar._day = result.Day;

                return calendar;
            }
            public void Show()
            {
                const int DayWeek = 7, Cursor = 5;
                string[] daysWeekRus = { "Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс" };

                DateTime temp = new DateTime(_year, _month, 1, new GregorianCalendar());

                ConsoleColor foregroundColor = ConsoleColor.White;

                switch (_month)// выбор цвета в зависимости от времени года
                {
                    case 1:
                    case 2:
                    case 12:
                        foregroundColor = ConsoleColor.Blue;
                        break;
                    case 3:
                    case 4:
                    case 5:
                        foregroundColor = ConsoleColor.Green;
                        break;
                    case 6:
                    case 7:
                    case 8:
                        foregroundColor = ConsoleColor.Yellow;
                        break;
                    case 9:
                    case 10:
                    case 11:
                        foregroundColor = ConsoleColor.Red;
                        break;
                }

                Console.ForegroundColor = foregroundColor;

                //Если нужен только месяц, то так: Console.WriteLine(DateTime.Now.ToString("MMMM")); // Июнь

                Console.Clear(); // очищаю консоль
                Console.SetCursorPosition(35, Cursor); // вывод месяца и года
                Console.WriteLine("{0} {1}", temp.ToString("MMMM"), _year); // вывод названия месяца и год числом

                Console.SetCursorPosition(15, Cursor + 2);// вывод дней недели
                foreach (string str in daysWeekRus)
                    Console.Write(str + "\t");

                int start = (int)temp.DayOfWeek; // определяю номер дня недели
                if (start == 0) // (int)temp.DayOfWeek для воскресенья возвращает индекс 0
                    start = 7;
                start--; // считаю от 0, поэтому -1

                // +++++++++++++ вывод дней календаря ++++++++++++++

                Console.SetCursorPosition(15, Cursor + 4);

                // дни предыдущего месяца
                DateTime prev = temp.AddMonths(-1);
                int prevDays = DateTime.DaysInMonth(prev.Year, prev.Month);
                for (int i = start - 1; i >= 0; i--)
                {
                    Console.ForegroundColor = ConsoleColor.Gray;
                    Console.Write(prevDays - i);
                    Console.Write("  \t");
                }
                Console.ForegroundColor = foregroundColor;

                int num = start;
                for (int i = 1, j = 6; i <= DateTime.DaysInMonth(_year, _month); i++)// дней в месяце
                {
                    if (num == DayWeek - 2 || num == DayWeek - 1)// выделяю субботы и воскресенья
                        Console.BackgroundColor = ConsoleColor.DarkGray;
                    if (i == _day)
                        Console.BackgroundColor = ConsoleColor.Magenta;

                    Console.Write(i);

                    Console.BackgroundColor = ConsoleColor.Black;

                    Console.Write(" \t");

                    num++;

                    if (num == DayWeek)
                    { // если количество счётчик равен кол-ву дней в неделе,
                        Console.SetCursorPosition(15, Cursor + j); // переход на новую строку (следующую неделю)
                        j += 2; // увеличиваю для перехода на новую строку
                        num = 0; // и обнуление счётчика
                    }
                }

                // дни следующего месяца
                for (int i = 1; num > 0 && num < DayWeek; num++)
                {
                    Console.ForegroundColor = ConsoleColor.Gray;
                    Console.Write(i++);
                    Console.Write("  \t");
                }
            }
        }
        static void Main(string[] args)
        {
            LooseLeafCalendar calendar = new LooseLeafCalendar();

            ConsoleKeyInfo keyInfo;

            try
            {
                do
                {
                    calendar.Show();

                    keyInfo = Console.ReadKey(true);


                    if (keyInfo.Key == ConsoleKey.RightArrow)// клавиша: стрелка вправо
                        calendar++; // на месяц вперед

                    if (keyInfo.Key == ConsoleKey.LeftArrow)// клавиша: стрелка влево
                        calendar--; // на месяц назад

                    if (keyInfo.Key == ConsoleKey.UpArrow) // клавиша: стрелка вверх
                        calendar += 6; // на пол года вперед

                    if (keyInfo.Key == ConsoleKey.DownArrow)// клавиша: стрелка вниз
                        calendar -= 6; // на пол года назад

                    if (keyInfo.Key == ConsoleKey.PageUp) // клавиша: PgUp
                        calendar += 12; // на год вперед

                    if (keyInfo.Key == ConsoleKey.PageDown)// клавиша: PgDown
                        calendar -= 12; // на год назад
                    
                } while (keyInfo.Key != ConsoleKey.Enter);// клавиша: Enter
            }

            catch
            {
            }

            Console.ReadLine();
        }
    }

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using static System.Console;

namespace SimpleProject
{
    class CPoint
    {
        public int X { get; set; }
        public int Y { get; set; }
    }
    struct SPoint
    {
        public int X { get; set; }
        public int Y { get; set; }
    }
    class Program
    {
        static void Main()
        {
            // работа метода ReferenceEquals со ссылочными и значимыми типами

            //ссылочный тип
            CPoint cp = new CPoint { X = 10, Y = 10 };
            CPoint cp1 = new CPoint { X = 10, Y = 10 };
            CPoint cp2 = cp1;

            // хотя cp и cp1 содержат одинаковые значения, они указывают на разные адреса памяти
            WriteLine($"ReferenceEquals(cp, cp1) = {ReferenceEquals(cp, cp1)}"); // false

            // cp1 и cp2 указывают на один и тот же адрес памяти
            WriteLine($"ReferenceEquals(cp1, cp2) = {ReferenceEquals(cp1, cp2)}"); // true

            // значимый тип
            SPoint sp = new SPoint { X = 10, Y = 10 };

            // при передаче в метод ReferenceEquals выполняется упаковка,
            // упакованные объекты располагаются по разным адресам
            WriteLine($"ReferenceEquals(sp, sp) = {ReferenceEquals(sp, sp)}"); // false

            // работа метода Equals со ссылочными и значимыми типами
            
            //выполняется сравнение адресов ссылочных типов
            WriteLine($"Equals(cp, cp1) = {Equals(cp, cp1)}"); // false

            // значимый тип
            SPoint sp1 = new SPoint { X = 10, Y = 10 };

            // выполняется сравнение значений полей
            WriteLine($"Equals(sp, sp1) = {Equals(sp, sp1)}"); // true
        }
    }
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using System;
using static System.Console;

namespace SimpleProject
{
    class Point
    {
        public int X { get; set; }
        public int Y { get; set; }

        // переопределение метода Equals
        public override bool Equals(object obj)
        {
            return this.ToString() == obj.ToString();
        }

        // необходимо также переопределить метод GetHashCode
        public override int GetHashCode()
        {
            return this.ToString().GetHashCode();
        }

        public static bool operator ==(Point p1, Point p2)
        {
            return p1.Equals(p2);
        }

        public static bool operator !=(Point p1, Point p2)
        {
            return !(p1 == p2);
        }

        public static bool operator >(Point p1, Point p2)
        {
            return Math.Sqrt(p1.X * p1.X + p1.Y * p1.Y) > Math.Sqrt(p2.X * p2.X + p2.Y * p2.Y);
        }

        public static bool operator <(Point p1, Point p2)
        {
            return Math.Sqrt(p1.X * p1.X + p1.Y * p1.Y) < Math.Sqrt(p2.X * p2.X + p2.Y * p2.Y);
        }

        public override string ToString()
        {
            return $"Point: X = {X}, Y = {Y}.";
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Point point1 = new Point { X = 10, Y = 10 };
            Point point2 = new Point { X = 20, Y = 20 };

            WriteLine($"point1: {point1}");
            WriteLine($"point2: {point2}\n");

            WriteLine($"point1 == point2: {point1 == point2}"); // false
            WriteLine($"point1 != point2: {point1 != point2}\n"); // true

            WriteLine($"point1 > point2: {point1 > point2}"); // false
            WriteLine($"point1 < point2: {point1 < point2}"); // true
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		Перегрузка выполняется по следующим правилам:
 - оператор true должен возвращать значение true, если состояние объекта истинно и false в противном случае;
 - оператор false должен возвращать значение true, если состояние объекта ложно и false в противном случае;
 - операторы true и false надо перегружать в паре.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		Для того чтобы это стало возможным, необходимо выполнить ряд требований:
 - в классе должна быть выполнена перегрузка операторов true и false;
 - в классе необходимо перегрузить логические операторы & и |;
 - методы перегрузки операторов & и | должны возвращать тип класса, в котором осуществляется перегрузка;
 - параметрами в методах перегрузки операторов & и | должны быть ссылки на класс, который содержит перегрузку.


using static System.Console;

namespace SimpleProject
{
    class Point
    {
        public int X { get; set; }
        public int Y { get; set; }

        public static bool operator true(Point p)
        {
            return p.X != 0 || p.Y != 0 ? true : false;
        }

        public static bool operator false(Point p)
        {
            return p.X == 0 && p.Y == 0 ? true : false;
        }

        // перегружаем логический оператор |
        public static Point operator |(Point p1, Point p2)
        {
            if ((p1.X != 0 || p1.Y != 0) || (p2.X != 0 || p2.Y != 0))
                return p2;

            return new Point();
        }

        // перегружаем логический оператор &
        public static Point operator &(Point p1, Point p2)
        {
            if ((p1.X != 0 && p1.Y != 0) && (p2.X != 0 && p2.Y != 0))
                return p2;

            return new Point();
        }

        public override string ToString()
        {
            return $"Point: X = {X}, Y = {Y}.";
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Point point1 = new Point { X = 10, Y = 10 };
            Point point2 = new Point { X = 0, Y = 0 };

            WriteLine($"point1: {point1}");
            WriteLine($"point2: {point2}\n");

            Write("point1 && point2: ");

            if (point1 && point2)
            {
                WriteLine("true");
            }
            else
            {
                WriteLine("false");
            }

            Write("point1 || point2: ");

            if (point1 || point2)
            {
                WriteLine("true");
            }
            else
            {
                WriteLine("false");
            }
        }
    }
}

Для оператора && первый операнд проверяется с использованием перегруженного оператора false, если результат равен false,
 тогда дальнейшее сравнение операндов осуществляется с использованием перегруженного оператора &, результат этого сравнения
 проверяется вызовом перегруженного оператора true, так как используется условный оператор.
 Если результат оператора false для первого операнда будет равен true, тогда оператор & выполняться не будет, а параметром для оператора true будет являться первый операнд.

Для оператора || первый операнд проверяется с использованием перегруженного оператора true, если результат равен false, тогда дальнейшее сравнение операндов осуществляется
с использованием перегруженного оператора |, результат этого сравнения также проверяется вызовом перегруженного оператора true (условный оператор).
Если результат оператора true для первого операнда будет равен true, тогда оператор | выполняться не будет, а параметром для оператора true будет являться первый операнд.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using static System.Console;

namespace SimpleProject
{
    abstract class Figure
    {
        public abstract void Draw();
    }

    abstract class Quadrangle : Figure { }

    class Rectangle : Quadrangle
    {
        public int Width { get; set; }
        public int Height { get; set; }

        public static implicit operator Rectangle(Square s)
        {
            return new Rectangle { Width = s.Length * 2, Height = s.Length };
        }

        public override void Draw()
        {
            for (int i = 0; i < Height; i++, WriteLine())
            {
                for (int j = 0; j < Width; j++)
                {
                    Write("*");
                }
            }
            WriteLine();
        }

        public override string ToString()
        {
            return $"Rectangle: Width = {Width}, Height = {Height}";
        }
    }

    class Square : Quadrangle
    {
        public int Length { get; set; }

        public static explicit operator Square(Rectangle rect)
        {
            return new Square { Length = rect.Height };
        }

        public static explicit operator int(Square s)
        {
            return s.Length;
        }

        public static implicit operator Square(int number)
        {
            return new Square { Length = number };
        }

        public override void Draw()
        {
            for (int i = 0; i < Length; i++, WriteLine())
            {
                for (int j = 0; j < Length; j++)
                {
                    Write("*");
                }
            }
            WriteLine();
        }
        
        public override string ToString()
        {
            return $"Square: Length = {Length}";
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Rectangle rectangle = new Rectangle { Width = 5, Height = 10 };
            Square square = new Square { Length = 7 };

            Rectangle rectSquare = square;
            WriteLine($"Неявное преобразование квадрата ({square}) к прямоугольнику.\n{rectSquare}\n");
            //rectSquare.Draw();

            Square squareRect = (Square)rectangle;
            WriteLine($"Явное преобразование прямоугольника ({rectangle}) к квадрату.\n{squareRect}\n");
            //squareRect.Draw();

            WriteLine("Введите целое число.");
            int number = int.Parse(ReadLine());
            Square squareInt = number;
            WriteLine($"Неявное преобразование целого ({number}) к квадрату.\n{squareInt}\n");
            //squareInt.Draw();

            number = (int)square;
            WriteLine($"Явное преобразование квадрата ({square}) к целому.\n{number}");
        }
    }
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Разработать класс Fraction, представляющий простую дробь. В классе предусмотреть два поля: числитель и знаменатель дроби.
Выполнить перегрузку следующих операторов: +,-,*,/,==,!=,<,>, true и false.
Арифметические действия и сравнение выполняется в соответствии с правилами работы с дробями.
Оператор true возвращает true если дробь правильная (числитель меньше знаменателя), оператор false возвращает true если дробь неправильная (числитель больше знаменателя).

