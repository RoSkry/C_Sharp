Ограничение обобщения	Описание
where T: struct	Параметр типа должен наследоваться от system.ValueType, т.е. быть структурным типом
where T: class	Параметр типа не должен наследоваться от system.ValueType, т.е. быть ссылочным типом
where T: new() 	Класс должен иметь конструктор по умолчанию (указывается последним)
where T: BaseClass	Параметр типа должен быть производным классом от указанного базового класса
where T: Interface	Параметр типа должен реализовать указанный интерфейс


////////////////


// Класс MyGenericClass унаследован от Object, причем содержащиеся 
//в нем элементы должны иметь конструктор по умолчанию.
class MyGenericClass<T> where T: class, IComparable, new()
    {... }

// MyGenericClass унаследован от Object, причем содержащиеся 
//в нем элементы должны относиться к классу, реализующему IDrawable. 
//и поддерживать конструктор по умолчанию. 
public class MyGenericClass<T> where T : class, IDrawable, new() 
{...} 

// MyGenericClass унаследован от MyBase и реализует ISomelnterfасе, 
// причем содержащиеся элементы должны быть структурами. 
public class MyGenericClass<T> : MyBase, ISomelnterface where T : struct 
{...}

Кстати, при построении обобщенного типа, специфицирующего несколько  параметров-типов, можно указать уникальный набор ограничений для каждого:

// <К> должен иметь конструктор по умолчанию, в то время как <Т> 
// должен реализовывать обобщенный интерфейс IComparable. 
public class MyGenericClass<K, T> where К : new() 
where T : IComparable<T> 
{...} 

Имейте в виду, что обобщенные методы также могут использовать ключевое слово where. Например, если необходимо гарантировать, что методу Swap() 
будут  передаваться только типы, унаследованные от System.ValueType, созданному ранее в этой главе, обновите код соответствующим образом:

// Этот метод обменяет местами два типа значения, но не классы. 
static void Swap<T>(ref T a, ref T b) where T : struct 
{ 
} 
