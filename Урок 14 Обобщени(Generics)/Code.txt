
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using static System.Console;

namespace SimpleProject
{
    /// <summary>
    /// Вспомогательный класс для профилирования участка кода
    /// выполняет измерения времени выполнения
    /// и подсчет количества сборок мусора
    /// </summary>
    internal sealed class OperationTimer : IDisposable
    {
        long _startTime;
        string _text;
        int _collectionCount;

        public OperationTimer(string text)
        {
            PrepareForOperation();

            _text = text;

            // сохраняется количество сборок мусора, выполненных на текущий момент
            _collectionCount = GC.CollectionCount(0);

            // сохраняется начальное время
            _startTime = Stopwatch.GetTimestamp();
        }

        /// <summary>
        /// Вызывается при разрушении объекта
        /// Выводит:
        /// значение времени, прошедшего с момента создания объекта 
        /// до момента его удаления
        /// количество выполненных сборок мусора, выполненных за это время
        /// </summary>
        public void Dispose()
        {
            WriteLine($"{_text}\t{(Stopwatch.GetTimestamp() - _startTime) / (double)Stopwatch.Frequency:0.00} секунды (сборок мусора {GC.CollectionCount(0) - _collectionCount})");
        }
        /// <summary>
        ///Метод удаляются все неиспользуемые объекты
        ///Это надо для "чистоты эксперимента",
        ///т.е. чтобы сборка мусора происходила только для объектов,
        ///которые будут создаваться в профилируемом блоке кода
        ///</summary>
        private static void PrepareForOperation()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }
    }
    class Program
    {
        /// <summary>
        /// метод для тестирования производительности 
        /// обобщенного и необобщенного списка
        /// </summary>
        private static void ValueTypePerfTest()
        {
            const int COUNT = 10000000;

            //объект OperationTimer 
            //создается перед началом использования коллекции
            //после завершения ее использования 
            //выводит время, затраченное на работу с коллекцией  
            using (new OperationTimer("List"))
            {
                //использование обобщенного списка
                List<int> list = new List<int>(COUNT);
                for (int n = 0; n < COUNT; n++)
                {
                    list.Add(n);
                    int x = list[n];
                }
                list = null; // для гарантированного выполнения сборки мусора
            }

            using (new OperationTimer("ArrayList"))
            {
                //использование необобщенного списка
                ArrayList array = new ArrayList();
                for (int n = 0; n < COUNT; n++)
                {
                    array.Add(n); //выполняется упаковка
                    int x = (int)array[n]; //выполняется распаковка
                }
                array = null; // для гарантированного выполнения сборки мусора
            }
        }
        static void Main(string[] args)
        {
            ValueTypePerfTest();
        }
    }
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

При выделении памяти в куче каждый объект проверяется на наличие метода Finalize(), если он есть, тогда объект помечается как финализируемый и ссылка на него сохраняется в специальной очереди – очереди финализации. Когда запускается сборщик мусора, он проверяет, является ли текучий объект финализируемым и выполнена ли для него финализация.
Если финализация не выполнена, то сборщик мусора помещает этот объект в специальную таблицу объектов, доступных для финализации. После чего он создает отдельный поток, в котором для всех объектов в этой таблице вызывается метод Finalize(), а сам тем временем очищает память объектов не требующих финализации. И только при следующем вызове сборщика мусора финализируемые объекты будут уничтожены.
Таким образом, получается, что для очистки памяти, выделенной под финализируемые объекты, требуется два вызова сборщика мусора.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using System;
using static System.Console;

namespace SimpleProject
{
    class DisposeExample : IDisposable
    {
        //используется для того, чтобы выяснить, вызывался ли метод Dispose()
        private bool isDisposed = false;

        private void Cleaning(bool disposing) // вспомогательный метод
        {
            // убедиться, что ресурсы ещё не освобождены
            if (!isDisposed) // очищать только один раз
            {
                //если true, то освобождаем все управляемые ресурсы
                if (disposing)
                {
                    WriteLine("Освобождение управляемых ресурсов");
                }
                WriteLine("Освобождение неуправляемых ресурсов");
            }
            isDisposed = true;
        }

        public void Dispose()
        {
            // вызов вспомогательного метода
            // true - очистка инициирована пользователем объекта
            Cleaning(true);
            // запретить сборщику мусора осуществлять финализацию
            GC.SuppressFinalize(this);
        }

        ~DisposeExample()
        {
            // false указывает на то, что очистку инициировал сборщик мусора
            Cleaning(false);
        }
        public void DoSomething()
        {
            WriteLine("Выполнение определенных операций");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            DisposeExample test = new DisposeExample();
            try
            {
                test.DoSomething();
            }
            finally
            {
                test.Dispose();
            }
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using static System.Console;

namespace SimpleProject
{
    /// <summary>
    /// Обобщенный класс точки
    /// </summary>
    /// <typeparam name="T">
    /// координаты точки могут быть любого типа
    /// </typeparam>
    public class Point2D<T>
    {
        //параметр типа используется для задания типа свойства
        public T X { get; set; }
        public T Y { get; set; }

        //параметр типа используется для задания типов параметров метода
        public Point2D(T x, T y)
        {
            X = x;
            Y = y;
        }
        public Point2D()
        {
            X = default(T);
            Y = default(T);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            //тестирование обобщенного класса - точки в 2D
            Point2D<int> p1 = new Point2D<int>();
            WriteLine($"x = {p1.X} y = {p1.Y}");
            WriteLine(typeof(Point2D<int>));

            Point2D<double> p2 = new Point2D<double>(10.5, 20.5);
            WriteLine($"\nx = {p2.X} y = {p2.Y}");
            WriteLine(typeof(Point2D<double>));
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using static System.Console;

namespace SimpleProject
{
    class GenericClass<T>
    {
        public void M1(T obj)
        {
            WriteLine($"Параметр: {obj}");
        }

        public virtual void M2(T data)
        {
            WriteLine($"Generic: {data}");
        }
    }
    class InheritClass : GenericClass<int> // необходимо явно указывать тип
    {
        public override void M2(int data)
        {
            WriteLine($"Inherit: {data}");
        }
    }
    class Program
    {
        static void Main()
        {
            InheritClass obj = new InheritClass();
            obj.M1(45);
            obj.M2(82);
        }
    }
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using static System.Console;

namespace SimpleProject
{
    class BasicClass
    {
        protected int age;
    }

    class GenericClass<T> : BasicClass
    {
        public void M1(T obj)
        {
            age = 57;
            WriteLine($"Basic: {age}\nGeneric: {obj}");
        }
    }

    class Program
    {
        static void Main()
        {
            GenericClass<int> obj = new GenericClass<int>();
            obj.M1(45);
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using static System.Console;

namespace SimpleProject
{
    class A<T>
    {
        public class Inner
        {
        }
    }

    class B<T>
    {
        //вложенный класс имеет собственный список параметров типа
        public class Inner<U>
        {
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            //для использования вложенного класса 
            //необходимо указать реальный тип вместо параметра типа внешнего класса
            A<int>.Inner a = new A<int>.Inner();
            WriteLine(a);
            A<double>.Inner a1 = new A<double>.Inner();
            WriteLine(a1);

            //для использования вложенного класса 
            //необходимо указать реальный тип вместо параметра типа вложенного класса
            B<int>.Inner<string> b = new B<int>.Inner<string>();
            WriteLine(b);
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using System;
using static System.Console;

namespace SimpleProject
{
    class Program
    {
        static T MaxElement<T>(T[] arr) where T : IComparable<T>
        {
            T max = arr[0];
            foreach (T item in arr)
            {
                if (item.CompareTo(max) > 0)
                    max = item;
            }
            return max;
        }
        static void Main(string[] args)
        {
            int[] arrInt = new int[] { 22, 63, 718, 14, 5 };

            //реальный тип для параметра типа указывается явно
            WriteLine($"Максимальный элемент: {MaxElement<int>(arrInt)}");

            double[] arrDouble = new double[] { 45.62, 77.354, 18.48, 11.3 };

            //реальный тип определяется по типу переданного массива
            WriteLine($"Максимальный элемент: {MaxElement(arrDouble)}");
        }
    }
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using System;
using System.Collections.Generic;
using static System.Console;

namespace SimpleProject
{
    class DateComparer : IComparer<Student>
    {
        public int Compare(Student x, Student y)
        {
            return DateTime.Compare(x.BirthDate, y.BirthDate);
        }
    }

    class Student : IComparable<Student>
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime BirthDate { get; set; }

        public override string ToString()
        {
            return $"Фамилия: {LastName}, Имя: {FirstName}, Родился: {BirthDate.ToLongDateString()}";
        }

        public int CompareTo(Student other)
        {
            return LastName.CompareTo(other.LastName);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            List<Student> auditory = new List<Student> {
                new Student {
                    FirstName ="John",
                    LastName ="Miller",
                    BirthDate =new DateTime(1997,3,12)
                },
                new Student {
                    FirstName ="Candice",
                    LastName ="Leman",
                    BirthDate =new DateTime(1998,7,22)
                }
            };

            WriteLine("+++++++++++++++++ список студентов ++++++++++\n");

            foreach (Student student in auditory)
            {
                WriteLine(student);
            }

            WriteLine("\n+++++++++++++++ сортировка по фамилии ++++++++\n");

            auditory.Sort();

            foreach (Student student in auditory)
            {
                WriteLine(student);
            }

            WriteLine("\n+++++++++ сортировка по дате рождения ++++++++\n");

            auditory.Sort(new DateComparer());

            foreach (Student student in auditory)
            {
                WriteLine(student);
            }
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using System;
using System.Collections.Generic;
using static System.Console;

namespace SimpleProject
{
    class Student
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime BirthDate { get; set; }

        public override string ToString()
        {
            return $"Фамилия: {LastName}, Имя: {FirstName}, Родился: {BirthDate.ToLongDateString()}";
        }
    }
    class Auditory
    {
        List<Student> _auditory = new List<Student> {
                new Student {
                    FirstName ="John",
                    LastName ="Miller",
                    BirthDate =new DateTime(1997,3,12)
                },
                new Student {
                    FirstName ="Candice",
                    LastName ="Leman",
                    BirthDate =new DateTime(1998,7,22)
                },
                new Student {
                    FirstName ="Joey",
                    LastName ="Finch",
                    BirthDate =new DateTime(1996,11,30)
                },
                new Student {
                    FirstName ="Nicole",
                    LastName ="Taylor",
                    BirthDate =new DateTime(1996,5,10)
                }
            };
        public IEnumerator<Student> GetEnumerator()
        {
            for (int i = 0; i < _auditory.Count; i++)
            {
                yield return _auditory[i];
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Auditory auditory = new Auditory();

            WriteLine("+++++++++++++++ список студентов ++++++++++++\n");

            foreach (Student student in auditory)
            {
                WriteLine(student);
            }
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using System.Collections.Generic;
using static System.Console;

namespace SimpleProject
{
    class NamedIterator
    {
        const int LIM = 10;
        int _limit;
        public NamedIterator(int limit)
        {
            _limit = limit;
        }
        public IEnumerator<int> GetEnumerator()
        {
            for (int i = 0; i < _limit; i++)
            {
                if (i == LIM)
                {
                    yield break; // прерывание итератора по условию
                }
                yield return i;
            }
        }

        public IEnumerable<int> GetRange(int start)
        {
            for (int i = start; i <= _limit; i++)
            {
                yield return i;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Write("Введите начальное значение: ");
            int start = int.Parse(ReadLine());

            Write("\nВведите конечное значение: ");
            int end = int.Parse(ReadLine());
            NamedIterator namedIterator = new NamedIterator(end);

            Write("\nВсе значения: ");
            foreach (int item in namedIterator)
            {
                Write($"{item} ");
            }

            Write("\n\nЗначения в заданном диапазоне: ");
            foreach (int item in namedIterator.GetRange(start))
            {
                Write($"{item} ");
            }
            WriteLine();
        }
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

using System.Collections.Generic;
using static System.Console;

namespace SimpleProject
{
    /// <summary>
    /// Обобщенный интерфейс с методам вычисления суммы
    /// </summary>
    /// <typeparam name="T"></typeparam>
    interface ICalc<T>
    {
        T Sum(T b);
    }
    class Program
    {
        /// <summary>
        /// Необобщенный класс, реализующий интерфейс ICalc
        /// </summary>
        class CalcInt : ICalc<CalcInt>
        //при наследовании указывается реальный тип данных
        {
            int _number = 0;
            public CalcInt(int n)
            {
                _number = n;
            }

            //при реализации методов вместо обобщенного типа 
            //используется тип CalcInt
            public CalcInt Sum(CalcInt b)
            {
                return new CalcInt(_number + b._number);
            }

            public override string ToString()
            {
                return _number.ToString();
            }
        }
        /// <summary>
        /// Обобщенный класс, который содержит в себе 
        /// коллекцию данных обобщеного типа
        /// и имеет метод вычисления суммы
        /// Для вычисления суммы задается оганичение: 
        /// параметр типа должен реализовать интерфейс ICalc<T>
        /// </summary>
        /// <typeparam name="T"></typeparam>
        class MyList<T> where T : ICalc<T>
        {
            //коллекция данных обобщенного типа
            List<T> list = new List<T>();
            //метод добавления данных в коллекцию
            public void Add(T t)
            {
                list.Add(t);
            }
            //метод вычисления суммы
            public T Sum()
            {
                if (list.Count == 0)
                {
                    return default(T);
                }
                T result = list[0];
                //для суммирования используется метод интерфейса ICalc<T>
                for (int i = 1; i < list.Count; i++)
                {
                    result = result.Sum(list[i]);
                }
                return result;
            }
        }

        static void Main(string[] args)
        {
            MyList<CalcInt> myList = new MyList<CalcInt>();
            myList.Add(new CalcInt(10));
            myList.Add(new CalcInt(20));
            myList.Add(new CalcInt(23));
            WriteLine($"Сумма элементов коллекции: {myList.Sum()}");
        }
    }
}
